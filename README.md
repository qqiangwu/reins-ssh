# 架构
## 前台不表
## 后台
典型的ＭＶＣ＋三层架构。

###　ＳＳＨ
+ Spring: 系统的所有对象均由ｓｐｒｉｎｇ托管，ｓｐｒｉｎｇ会自动创建对象及依赖注入。
+ Struts: 只做路由，所以的请求会被导到相应的控制器(Ａｃｔｉｏｎ或者Ａｐｉ)
+ Hibernate: ORM

下面以/ａｃｔｉｏｎ/ｎｅｗｓ/ｓｕｂｐａｇｅ/１为例，说明整个流程

### 控制层(Ａｃｔｉｏｎ)
请求被ｓｔｒｕｔｓ导到ＶｉｅｗＳｕｂＰａｇｅＡｃｔｉｏｎ，ｓｔｒｕｔｓ会向ｓｐｒｉｎｇ要求一个ViewSubPageAction对象，ｓｐｒｉｎｇ会创建一个此对象，并注入相关依赖，将路由中最后的１提取取来，做为参数，调用对象的ｓｅｔＰａｇｅＮｕｍ方法注入参数。

Ａction调用相关Ｓｅｒｖｉｃｅ（业务层）完成业务，并准备好一个Ｍodel对象（在ViewSubPageAction中，是mResult）。

确保Ａction执行完毕后，ｇｅｔＸＸＸ方法可以用。则在渲染Ｊｓｐ时，Ｊsp中可以直接使用ＸＸＸ。

另外，作为Ａｊａｘ后端的控制器，我一律命名为ＸＸＸＡｐｉ。参见ViewNewsDetailApi了解如何返回ｊｓｏｎ对象。

#### Session
为了保证服务器无状态，我们将session放到了redis中，这样，各服务器可以共享session。

### 表现层(Ｊｓｐ)
根据ｓｔｒｕｔｓ-ｎｅｗ.ｘｍｌ的配置，ViewSubPageAction执行完毕后，调用/WEB-INF/view/news/subpage.jsp进行渲染。此时，我们可以直接在ｊｓｐ中调用`${result.XXX}`。

### 业务层(Ｓｅｒｖｉｃｅ)
ｃｏｍ.ｎ２ｃｊ.ｓｅｒｖｉｃｅ.ｉｍｐｌ中的一堆ＸＸＸＳｅｒｖｉｃｅＩｍｐｌ组成了业务层，控制层调用业务层来完成各种任务。

注意！所有Ｓｅｒｖｉｃｅ对象都是单例，所以，请确保这些对象都是线程安全的！默认情况下，如果它们都是无状态，那么，ｍｙｓｑｌ的事务机制可以保证对ｍｙｓｑｌ的操作都是线程安全的。

### 存储层(Ｄａｏ+Ｅｎｔｉｔｙ)
Ｍｙｓｑｌ　ＯＲＭ是在这一层做的。你们按照自己的业务，改成你们的数据库。

#### Cache示例:
为了避免大量的数据库读，我们使用cache缓存数据。同时，考虑到各种原因，我们将cache加在service层上，而不是dao层上。因为dao层我提供了公共实现，加cache不方便。

我们使用redis作为cache：
+ 具体设置见common/app.properties以及context-common.xml。
+ 示例代码见NewsServiceImpl。
+ 参考见[Spring Cache](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html)

当然，这是有限制的，你必须保证在Service函数返回后,不会再产生数据库调用，否则，从缓存中读出的对象，已经detach，会报no session错误。所以我现在没有开启缓存。你们自己看吧，可以继续用在dao层做cache手动控制的方法，或者保证service返回后就不会再调用数据库了。

实际上,hibernate支持二级缓存，但是只支持memcache，redis还不支持，我也懒得重新写一个了...

# 配置管理
所有的配置都放在了ｃｏｍｍｏｎ/ａｐｐ.ｐｒｏｐｅｒｉｔｅｓ，在代码中需要时，使用@Ｖａｌｕｅ注入，在ｓｐｒｉｎｇ配置文件中需要时，使用${}语法。注意，在生产环境中，我们可以提供一个新的配置文件，来对它进行覆盖。这个等你们要发布时再说吧。

另外，还在一个ｌｏｇｂａｃｋ.ｘｍｌ，是用来配置ｌｏｇ的，这个你们用默认的就行了，生产环境中同样会覆盖。

# 运行
+ 使用ｍａｖｅｎ运行:
    + 进行目录，运行ｍｖｎ　ｔｏｍｃａｔ７:ｒｕｎ
    + 打开浏览器，访问ｌｏｃａｌｈｏｓｔ:８０８０即可
+ 使用ｅｃｌｉｐｓｅ
    + 配置好ｔｏｍｃａｔ７
    + 在ｔｏｍｃａｔ７中，将项目的ｃｏｎｔｅｘｔＰａｔｈ设置为/(默认是/＋项目名)
    + 右键ｒｕｎＯｎＳｅｒｖｅｒ

# 发布
发布时还有一些注意事项，到时再说吧